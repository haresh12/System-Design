/**
 *   FROM NOW THIS LEARNING.JS WILL BE DEVIDED INTO TWO PARTS FIRST PART WILL CONTAINS BASICS LIKE ONLY IMPORTENT POINTS AND SENCOND PART
 *   WILL COVER INDEPTH KNOWLEDGE ON THOSE IMPORTENT POINTS
 */


/**
 *                                      PART ONE IMPORTENT POINTS
 * 
 * 
 *   COMMUNICATION TECHNIQUES =====> 
 * 
 *   Things that we are going to cover :
 * 
 *   Short Polling
 *   Long Polling
 *   Websocket
 *   Server Side Events 
 *   Webhooks (Differnt then websocket)
 * 
 * 
 *   WEBHOOKS IS LIT
 * 
 *   FOR FOREX APP REALLY POLLING WILL WORK BECAUSE IN FEW SECONDS MARKET CAN BE HELL CRASH
 * 
 * 
 *  SHORT POLLING : ===> Short Live connection => No persistance connection
 *          YOU HAVE 1M USER AND EVERY 5 SEC YOU MAKE REQUEST ITS HELL EVERY 10 SEC YOUR SERVER RECEIVE 1AM REQUEST
 * 
 *  SHORT POLLING IS SIMPLE ITS LIKE NORMAL REST CALL BUT IN SOME INTREVAL 
 * 
 *  ALWAYS INSURE REMOVE OR STOP SETINTERVAL()  clearInterval(interval)
 *  
 * 
 *  LONG POLLING : Single One lived connection
 *                 Connection is open until you get data or there is some timeout
 *                 Less number of request
 *      
 *                CONST : LOT OF ACTIVE CONNECTIONS I SEE I UNDERSTAND
 * 
 *                IN LONG POLLING SERVER CONFIG MATTERS
 *                
 * 
 * 
 *  WEB-SOCKET :   FULL DUPLEX COMMUNICATION 
 *                 Bidirectional Communication
 *                 Single long live TCP connection
 *                 
 *    HTTP UPGRAD REQUEST MUST UNDERSTAND FIRST REQUEST
 *    YES SOCKET.IO IS BEST FOR WEBSOCKET COMMUNICATION         SOCKET.IO CREATE ONE BASIC EXAMPLE
 * 
 *   connection , disconnect all this are events we have in Socket.io 
 * 
 *  101 swiching protocol =>>>>> MUST UNDERSTAND 
 * 
 *  Data framing 
 * 
 *  Connection limits in some of the provider
 *  
 *  Resource clean up is must its like event listner
 * 
 * 
 *  SERVER-SIDE EVENTS ===>>>>
 * 
 *      THIS IS I THING GOOD ONE AND NEW THING I LEARNED BECAUSE HERE YOU MAKE REQUEST ONE TIME TO SERVER AND AFTER THAT ITS SERVER JOB TO SEND EVENTS WHEN EVER SOME CHANGES HAPPEN
 * 
 *     EVENT STREAM SOMETHING NEW FOR ME
 * 
 *     NORMAL STRUCTURE : event | data | id
 * 
 *    OK ONE THING TO UNDERSTAND HERE IS FOR SERVER SIDE EVENTS AND WE DON'T HAVE ANY DIFFERENT LIBRARY OR SOMETHING THE ENTIRE GAME OF HEADER HERE WHEN WE MAKE REQUEST  OR WE CAN SAY WHEN WE 
 *    CRETE API WE JUST NEED TO CARE ABOUT SETTING UP FEW HEADERS
 * 
 * 
 *    setHeader('content-type','text/event-stream');
 *    setHeader('connection','keep-alive');
 *    setHeader('catch-control','no-cathe'); //  NO SURE THIS IS NEEDED OR NOT BUT ABOVE 2 1000% MAKE SENSE
 * 
 * 
 *    EventSource(); // new thing that provided by all morden browser MAKE SURE GO DEEP INTO THIS FOR SURE
 * 
 *    SO SERVER SIDE HEADERS METTERS AND CLIENT SIDE EVENSOURCE MATTERS
 *         
 */



/**
 *                                        IN DEPTH FOR EACH TOPIC
 * 
 * 
 *    SEE ONE THING WE NEED TO BE CLEAR BEFORE WE START ANY MODULE IS LIKE WHAT WE ARE GOING TO COVER INTO THAT MODULE.
 * 
 *    SO IN THIS MODULE WE ARE GOING TO TALK ABOUT COMUNICATION TECHNIQUES AND WHAT DO WE MEAN BY THAT IS LIKE WHAT ARE THE DIFFERENT
 *    OPTIONS WE HAVE FOR COMMINCATION HOW DIFFERENTS WAY CLIENT AND SERVER CAN COMMINCATE SO THATS ALL WE ARE GOING TO COVER LETS LIST
 *    OUT THE TOPICS
 * 
 *    1. SHORT POLLING 
 *    2. LONG POLLING (MUST GO DEEP AND I NEED TO SEE REAL WORLD EXAMPLE FOR THIS)
 *    3. WEBSOCKET : (MOSTLY EVERY ONE HAS HEARD ABOUT IT AND USED IT ATLEAST ONCE)
 *    4. SERVER SIDE EVENTS : (NEW FOR ME)
 *    5. WEBHOOK (FAMOUS BUT ONCE ITS LIKE SIMPLE POST API WHICH GET TRIGGERED AFTER SOME SPECIFIC EVENT) (PAYMENT CONFIRMATION IS BEST EXAMPLE)
 * 
 *    IMPORTENT QUESTION THAT CAN BE ASKED 
 *        >>DIFFERANCE BETWEEN ALL OF THEM 
 *        >> UNIDIRECTIONAL AND  BIDIREACTIONAL   (THIS IS MUST MUST MUST DO QUESTION)
 * 
 * 
 *                               BEFORE GOING DEEP INTO EACH OF THE TECHNIQUE LET'S GO WITH ONE EXAMPLE
 * 
 * 
 *    SEE YOU VISITED ONE RESTAURANT WHERE YOU VISITED
 * 
 *        >>> SHORT POLLING : YOU ORDERD SOMETHING FROM RESTAURANT WAITOR TOOK YOUR ORDER NOW AS YOU ARE HUNGER AND CAN'T NOT WAIT MORE
 *                            AGAIN AND AGAIN YOU ASK WAITOR IS ORDER IS READY AND WAITOR GOES TO KITCHEN TO GET UPDATE AND COMES WITH
 *                            RESPONSE . THIS IS BASICALLY SHORT POLLING WHERE IN SOME INTERVAL AGAIN AND AGAIN YOU MAKE NEW CONNECTION
 *                            WITH SERVER AND SERVER COMES BACK TO YOU WITH RESPONSE
 * 
 * 
 *    >>>> LONG POLLING : NOW HERE WAITOR BECOME SMART AND AS SOON AS YOU ASKED WAITOR BHAI KAHANA READY HAI HE GOES TO KITCHEN AND STANDS
 *                        THERE UNTIL FOOD IS PREPARED AND COMES ONLY WHEN FOOD IS READY THIS WAY WAITOR DOES NOT HAVE TO COME AND GO AGAIN
 *                        AND AGAIN.
 * 
 * 
 *   >>>>  WEBSOCKET :  NOW HERE YOU BECAME SMART YOU UNDERSTOOD THAT LAST TIME I ASKED 10 ITEMS TOGETHER THEN IT TOOK SO LONG SO YOU ORDER
 *                      ONE ITEM AND ASKED WAITOR TO KEEP MENU HERE AND I WILL KEEP ORDERING YOU THIS WAY WAITOR AND YOU BOTH ARE IN CONNECTION
 *                      UNTIL YOU ARE NOT DONE WITH YOUR FOOD
 * 
 *  
 *  >>>>> SERVER-SIDE-EVENT : NOW HERE YOUR ROLE IS LIKE NASIB VALE HO BECAUSE SOMEONE HAS BIRTHDAY AND HE ANNOUNCED DRINKS ON ME. SO WAITOR 
 *                            CAME TO YOU AND GAVE YOU DRINK . UNDERSTAND THIS EXAMPLE AS DEEP AS YOU CAN BECAUSE THIS TECHNIQUE IS ALSO VERY
 *                            USEFULL.  ITS LIKE ONE TIME YOU MADE CONNECTION WITH SERVER AND AFTER THAT ANY CHANGES HAPPENS IN SERVER THEN 
 *                            SERVER WILL SEND YOU EVENT . FOR ME ITS LIKE ONE WAY COMMUNICATION BECAUSE HERE CLIENT JOB IS JUST CONNECT FOR 
 *                            ONE TIME.  
 * 
 *                            (FOR SERVER SIDE EVENTS SPEND EXTRA TIME AND CREATE ONE GOOD DEMO)
 * 
 * 
 *  >>>>> WEBHOOK :  FOR THIS I DON'T HAVE ANY GOOD EXAMPLE BUT USED MANY TIME SEE ITS JUST ONE POST URL WHICH WILL BE TRIGGERD ONCE SOME SPECIFIC
 *                   EVENT IS COMPETED AND YOU WANTED TO NOTIFY THAT TO CLIENT. (MOSTLY WE HAVE SEEN IN PAYMENT CONFIRMATION I HAVE USE IN STREAM
 *                   CHAT ALSO)
 *   
 */


/**
 *                                                    SHORT POLLING
 * 
 * 
 *  SO AGAIN IF WE START FROM THE BASICS WHEN WE TALK ABOUT SHORT POLLING IT SIMPLY MEANS THAT IS SOME INTERVAL CLIENT IS GOING TO ASK FOR NEW
 *  INFORMATION TO SERVER TO GET UPDATED DATA
 *              
 *                      SENDING YOU REQUEST
 *   CLIENT REQUEST  ===============================>>>>. SERVER
 * 
 *              THIS IS YOUR RESPONSE
 *   CLIENT  <===================================  SERVER RESPONSE
 * 
 *            (AGAIN AFTER SOME INTERVAL EX 5000 MS )
 *     
 *  CLIENT REQUEST  ===============================>>>>. SERVER
 * 
 *              THIS IS YOUR RESPONSE
 *   CLIENT  <===================================  SERVER RESPONSE
 * 
 *            (AGAIN AFTER SOME INTERVAL EX 5000 MS )

 *   
 *  CLIENT REQUEST  ===============================>>>>. SERVER
 * 
 *              THIS IS YOUR RESPONSE
 *   CLIENT  <===================================  SERVER RESPONSE
 * 
 *  
 *  HERE SEE CLIENT IS SENDING REQUEST AGAIN AND AGAIN AND SERVER IS RESPONEDING BUT THERE ARE CHANCES THAT CLIENT MY RECEIVE SAME DATA AS SERVER
 *  MIGHT NOT HAVE ANY UPDATE FOR CLIENT . STILL CLIENT WILL ASK AGAIN AND AGAIN
 *   
 *  HERE CONEECTION IS SHORT LIVE  MOSTLY THE TCP HANDSHAKE WILL ALSO HAPPEN WITH EACH REQUEST BUT THAT IS SOMETHING WE CAN SET THROUGH HEADER
 *   
 * 
 *      SOME OF THE CHARCTORSTICS :
 *  
 *            1. Short live connection
 *            2. No persistance connection (To be real same as first one)
 *            3. Less resource utility
 *            4. Problem with large user base
 * 
 * 
 *  HERE WE NEED TO UNDERSTAND POINT 4 : SEE THING ABOUT IT YOU HAVE 1 MILLION USER PINGING SERVER EVERY 5 OR 10 SECONDS THIS COULD BE HELL IN SAME
 *                                       CASES NOW ALSO HERE ANOTHER PROBLEM IS LIKE EVEN MILLIONS USER ARE UPDATING DATA BUT MOST OF THEM WON'T HAVE
 *                                       ANY NEW UPDATE FROM SERVER .
 * 
 *      
 *    SOME OF THE EXAMPLE WHERE WE CAN USE SHORT POLLING.
 *   
 *        YOUTUB LIVE CHAT IS THE BEST ONE THAT I HAVE SEEN  (BEST)
 *        ANALYTICS DASHBOARD
 *        NOTIFICATION (NOT SURE HOW THIS WHILL BE GOOD FIT THERE)
 *        Crickinfo the way the update there commentry is also good use case.  (SECOND BEST)
 *        VERSION UPDATE 
 * 
 * 
 *  IN COMMUNICATION TECHNIQUES WE HAVE CREATED ONE SIMPLE EXAMPLE WHERE WE NEED TO SHOW DIFFERENT NUMBER FROM 1 TO 10 ITS LIKE LOTTERY SYSTEM
 *  JISKA NUMBER AAYA VO WINNER
 * 
 *  ONE MUST THING IF YOU WANTED TO LEARN FROM HERE IS ALWAYS ALWAYS CLEAR THE INTERVAL ONCE YOU ARE DONE WITH YOUR TASK
 */



/***
 *                                               LONG POLLING 
 * 
 * 
 *   IN CASE OF LONG POLLING CLIENT MAKES REQUEST TO SERVER NOW SERVER DOES NOT QUICKLY RESPONSE IT WILL RESPONSE ONLY ONCE SERVER DOES HAVE NEW
 *   UPDATED THEN IT WILL SEND THE REPOSNSE TO CLIENT.
 * 
 *   SO ONE THING TO LEARN HERE THAT IN CASE OF LONG POLLING CONNECTION IS LONG LIVE.
 * 
 * 
 *  CLINET REQUEST ==============================================>  SERVER 
 *                                               
 *                                                                  (WAITNG  AS NO NEW DATA)
 * 
 *       // TILL THIS ENTIRE WAITING TIME CONNECTION WILL
 *          BE OPEN                                                  (WAITNG AS NO NEW DATA)
 * 
 *            
 *  CLIENT  <======================================================  (FINALLY SERVER HAS NEW DATA)
 * 
 * 
 *  SO IN CASE OF LONG POLLING ONLY WAY CONNECTION WILL BE DISCONNECED 1. EITHER CLINT GOT NEW UPDATE
 *                                                                     2. TIMOUT
 * 
 *  IN CASE OF SHORT POLLING ISSUE WAS WE HAVE MANY REQUEST GOING TO SERVER BUT THAT CAN BE SOLVED WITH LONG POLLING BECAUSE CLIENT IS
 *  NOT ASKING AGAIN AND AGAIN FOR THE DATA
 * 
 *  BUT IN CASE OF LONG POLLING ANOTHER ISSUE WE HAVE IS MANY OPEN CONNECTION WITH SERVER SAME TIME WHICH IS BIG ISSUE
 * 
 *  
 *     FEW POINTS IF WE NEED TO WRITE ABOUT LONG POLLING IS :
 * 
 *         SINGLE LONG LIVED CONNECTION
 *         CONNECTION IS OPEN UNTIL YOU GET UPDATED DATA / TIMEOUT
 *         LARGE NUMBER OF CONNECTION WHEN WE HAVE LARGE USER BASE
 * 
 * 
 *    SOME USE CASES :  REAL TIME COLLEBRATION (TO BE REAL NOT REALLY I WILL FIND GOOD EXAMPLE AND UPDATE HERE)
 * 
 * 
 *  ONE OF THE MOST IMPORTENT THING ABOUT LONG POLLING SEE IN CASE OF SHORT POLLING WE DID NOT HAVE TO MAKE ANY CHANGES INTO SERVER TO SUPPORT IT
 *  BUT IN CASE OF LONG POLLING WE HAVE TO ADDED FEW HEADERS TO SUPPORT THE LONG POLLING.
 * 
 *  ALSO ONE INTERSTING THING WE ARE SAYING THAT SERVER WILL NOT SEND DATA TO CLIENT UNTIL WE HAVE SOME UPDATE BUT HOW SERVER IS HOLDING THE
 *  REQUEST WHAT EXECTLY ITS DOING
 *  
 * 
 *     // SORRY THIS LINES ARE TRUE FOR SERVER SIDE EVENTS
 *     SO BASICALLY TO HOLD RESPONSE IN EXPRESS IF YOU DON'T WRITE res.send() OR res.json() THEN THAT SPECIFIC REQUEST WILL BE HOLD 
 *     HERE IN OUR EXAMPLE WE ARE JUST PASSING THAT SPECIFIC DATA INTO ARRAY LIKE ARRAY.PUSH(res) THEN LATER ONCE WE HAVE UPDATED DATA
 *     WE WILL SEND THIS DATA TO EVERYONE HOW REQUESTED.
 * 
 *    // THIS ARE MUST KNOWN HEADER WE WILL LEARN MORE ABOUT IT BUT IN SSE 
 *    setHeader('content-type','text/event-stream');  // THIS IS LIT
 *    setHeader('connection','keep-alive');
 *    setHeader('catch-control','no-cathe'); //  NO SURE THIS IS NEEDED OR NOT BUT ABOVE 2 1000% MAKE SENSE
 * 
 * 
 *   
 *    TO BE REALLY IN LONG POLLING THIS EXAMPLE IS WEIRD SO BEFORE WE CLOSE THIS SECTION I WILL MAKE SMALL APP THAT USES LONG POLLING
 * 
 * 
 *   NEED BETTER UNDERSTANDING OF LONG POLLING 
 *  
 *  
 */ 



/**
 *                                                         WEB-SOCKET
 * 
 * 
 *  FIRST OF ALL THIS IS NOT SOMETHING NEW THAT WE HEARD WE KNOW WHEN TO USE SOCKET ITS MAINLY FOR NEAR REAL TIME COMMUNICATION
 * 
 *  
 *  FULL DUPLEX COMMUNICATION
 *  SINGLE LONG LIVED TCP CONNECTION 
 *  BIDIRECTIONAL COMMUNICATION
 * 
 *  UNDERSTAND THIS BASIC THING THAT TO EVEN START THIS WS CONNECTION WE NEED TO HAVE ONE HTTPS UPGRADE REQUEST TO SERVER AND AFTER THAT SERVER
 *  WILL OPEN NEW WEBSOCKET CONNECTION
 *  
 *  ONCE WEBSOCKET CONNECTION IS OPEN BETWEEN CLIENT AND SERVER THEN COMMUNCATION BETWEEN CLIENT AND SERVER BECOMES BI-DIRECTIONAL
 * 
 *  MEANS WE CAN EMIT CHANGES FROM CLIENT AND IT WILL REFLECTED TO SERVER AND SAME IF WE EMIT CHANGES FROM SERVER IT WILL BE REFLACTED TO CLIENT
 * 
 *  IMPORTENT THING HERE IS HOW COMMUNICATION GET STABLED LIKE USING HTTPS UPGRADE AND WE ALREADY LEARNED SWICHING PROTOCOL STATUS CODE 101
 * 
 * 
 * 
 *                                 (HTTP UPGRADE)
 *  CLIENT ===========================================================>   SERVER
 * 
 * 
 * 
 * 
 *                                  (OPEN CONNECTION)
 *  CLIENT <==========================================================    SERVER
 * 
 * 
 * 
 *                             (BI-DIRECTIONAL COMMUNICATION)
 *  CLIENT <===========================================================>  SERVER
 * 
 * 
 *                                      (CLOSE CONNECTION)
 *  CLIENT <===========================================================>  SERVER
 * 
 * 
 *   FEW FAMOUS LIBRARIES
 * 
 *    SOCKET.IO
 *    WS
 * 
 *  socket.emit('chat-message', message)
 * 
 *  SEE IN REAL EXAMPLE WE ALREADY WORKED WITH STREAM CHAT IN THAT ALSO WE HAVE MANY EVENTS CORRECT SO LIKE REMOVE , ADD , MESSAGE SO WHAT LIKE OF
 *  EVENT YOU WANTED TO EMIT IT WORKS ON THAT BASICALLY.
 * 
 *  IN SCOKET.IO ALSO WE HAVE SOME PRE-DEFINED EVENTS LIKE  connection , disconnect AND ALL
 * 
 *  SEE IT WORKS LIKE SUPPOSE WE HAVE 3 USER A B AND C NOW A USER EMITTED SOME SOMETHING THEN SERVER WILL LISTEN THOSE MESSAGES BUT INTERSTING PART
 *  IS NOW SERVER WILL SAY WE HAVE 2 MORE USER WHO NEEDS TO LISTEN THIS MESSAGE AND HERE SERVER WILL EMIT THAT MESSAGE TO B AND C
 * 
 *  SO USER A EMIT MESSAGE TO SERVER 
 *  SERVER EMIT MESSAGE TO USER B AND C 
 * 
 *  socket.emit() to emit the message
 *  socket.on() // write name of event your client will listen all changes for that specific event
 * 
 *  REMEBER HERE WE MAKE ONLY ONE REQUEST TO SERVER FOR SIWICHING PROTOCAL AFTER THAT ALL THE MESSAGE PASSING HAPPEN ON SAME CONNECTION AND THATS
 *  WHY EVEN IN NETWORK TAB YOU WON'T SEE NEW REQUEST FOR EVERY MESSAGE
 * 
 *  USE CASE
 *    ANALYTICS
 *    FINANCIAL TRADING
 *    ONLINE GAMING
 *    COLLAB TOOLS LIKE QUIP
 *  
 *  THIS IS INTERSTING THAT FOR ALL HTTPS REQUEST WE HAVE PROTOCOL http and https SAME WAY FOR WEB-SOCKET CONNECTION WHATEVER REQUEST TO MAKE WILL BE
 *  HAVE PROTOCOL ws AND WE CAN USE wss (WEBSOCKET SECURE) ALSO.
 * 
 * 
 *   CHALLENGES 
 *    
 *       RESOURCE USAGE
 *       CONNECTION LIMIT
 *       STICKY SESSION
 *       SCALING 
 *       TESTING/DEBUDING
 *       RESOURCE CLEAN UP (THIS IS LIT AND MUST DO ELSE WE WILL HAVE LONG CONNECTIONS HELL)
 *       BACKWARD COMPLETIBILITY
 * 
 * 
 *  SEE THE FIRST REQUEST COPIED FROM NETWORK TAB
 * 
 *  Request URL:
     ws://localhost:3000/socket.io/?EIO=4&transport=websocket&sid=o5noJAtdjKhiH0dfAAAC
     Request Method:  GET
     Status Code: 101 Switching Protocols
 
 */

/**
 *                                             SERVER SENT EVENT
 * 
 *  
 *  SERVER SENT EVENT (SSE) IS LIT THIS TECHNIQUE OF COMMUNICATION I HAVE NEVER USED BUT ITS INCREDIBLE AFTER LEARNING I CAN SEE DIFFERENT 
 *  USECASE SO FIRST LETS TALK ABOUT IT FIRST
 * 
 *  SSE IS NEW KIND OF COMMUNICATION TECHNIQUE WHICH IS SUPPORTED BY ALMOST ALL BROWSER HERE SEVER WILL SEND EVENTS TO CLIENT FOR EACH CHANGES.
 *  
 * 
 *                            (SENT FIRST REQUEST)
 *  CLIENT ===========================================================>  SERVER
 * 
 *                            (CONNECTION OPENED)
 *  CLIENT  <=========================================================== SERVER
 * 
 *                             (EVENT SENT)
 *  CLIENT  <=========================================================== SERVER
 * 
 *                              (EVENT SENT)
 *  CLIENT  <=========================================================== SERVER
 * 
 *                              (EVENT SENT)
 *  CLIENT  <=========================================================== SERVER
 * 
 *                  (Connection closed either we do or browser timout)
 *  CLIENT  ===========================================================> SERVER
 * 
 * 
 *  SSE HAS UNI-DIRECTIONAL COMMUNICATION IT MEANS ONLY ONE TIME CLIENT HAS TO CONNECT WITH SERVER OR HAS TO SEND THE REQUEST AFTER THAT
 *  SERVER WILL SEND EVENTS BASED ON ANY CHANGES MADE.
 * 
 *  SEE BIG DIFFERANT BETWEEN LONG POLLING AND SSE IS THAT HERE WE ARE NOT HALTING ANY RESPONSE UNTIL WE GET FULL RESPONSE HERE SO IN 
 *  CLIENT SIDE YOU WANT SEE LIKE REQUEST PENDING IN CROME RATHER YOU WILL SEE THEN WE HAVE SSE CONNECTION AND AS SOON AS SERVER WILL 
 *  HAVE ANY CHANGE CLIENT WILL RECEIVE IT.
 * 
 *   TO ACHIEVE SSE WE NEED TO ADD SOME HEADERS IN REQUEST 
 * 
 *          1. header.set('Connection', 'keep-alive'); 
 *          2. header.set('Content-Type', 'text/event-stream'); // THIS IS MUST WE ARE GOING TO PASS DATA IN STREAM
 *          3. header.set(''Catch', 'no-catch');
 * 
 * 
 *  ALSO NEXT QUESTION COMES IN MIND THAT YOU WE CAN RECEIVE THESE EVENTS AT CLIENT SIDE.
 * 
 *  SO IN CLIENT WE GET EVENSOURCE WHICH IS IN-BUILT FUNCTIONALITY OF BROWSER AND IN  THOSE EVENTSHOUCE YOU WILL GET 
 *  EACH NEW EVENT SEE IN SSE EXAMPLE.
 * 
 * 
 *  SEE SERVER SIDE WE HAVE TO SET HEADER AND THEN DO LIKE res.write BUT WE MUST UNDERSTAND FULL ON CLIENT SIDE
 * 
 * 
 *   <script>
      // Setup sse connection
      const eventSource = new EventSource("/sse"); // here /sse is endpoint that we created in backend;

      eventSource.onmessage = (event) => {
        console.log(event.data);
        const sseDataRef= document.getElementById('sse-data');
        sseDataRef.innerHTML += `<p>${event.data}</p>`;
      }; 
 * 

       SO IN SHORT EVENTSOURCE AT CLIENT SIDE AND THOSE 3 HEADERS AT SERVER SIDE and res.write() RATHER THEN res.send() OR res.json()
       THIS FEW THINGS ARE KEY TO ACHIEVE SERVER SIDE EVENTS COMMUNICATION TECHNIQUES.

       SSE CONNECTION IS LONG LIVE CONNECTION . FORMAT FO SENDING DATA IS IMPORTANT 

       SOME OF THE CHALLANGES THAT WE FACE :

                BROWSER COMPATIBILITY  (BECAUSE SOME BROWSER MAY NOT SUPPORT EVENTSOURCE)
                CONNECTION LIMIT (6 TO 8 CONNECTION MESE 1 CONNECTION HMESHA OPEN RHE RHA)
                CONNECTION TIMOUT
                BACKGROUND TAB BEHAVIOUR (WHAT AGAR TAB BACKGROUND ME GYA TO BROWSER IN EVENT BEJNE BAND KR DIYA)
                RESOURCE UTILIZATION
                TESTING AND DEBUDING

 */


/**
 *                                         WEB HOOKS
 * 
 * 
 *  I THING WEBHOOK IS SOMETHING THAT WE HAVE USED A LOT IN REAL APPLICATION SO I WON'T GO MUCH DEEP ON THAT.
 * 
 *  IT'S SIMPLE POST REQUEST THAT'S IT
 * 
 *  WE HAVE USED IT WITH STRIPE WHERE IN STRIPE YOU MUST HAVE TO PASS CALLBACK URL SO THAT ONCE PAYMENT IS SUCCESSFULL THEN IT CAN
 *  PASS THE MESSAGE KE BHAI PAYMENT MIL GYA HE AB AAP COURSE KA ACCESS DEDO. 
 * 
 *  BASICALLY HOW YOUR SEVER WILL KNOW THAT PAYMENT IS SUCCESS SO FOR THAT ONLY WE HAVE TO CREATE ONE API AND PROVIDE THAT TO STRIPE NOW
 *  ONCE STRIPE IS DONE WITH PROCESSING IT WILL CALL OUR API AND GIVE INFO WHETHER PAYMENT WAS SUCCESS OR NOT
 * 
 *  ANOTHER BEST OUT OF BEST EXAMPLE IS GITHUB IN THAT ALSO WE HAVE OPTION LIKE PASS CALL BACK URL IN WEBHOOK SECTION THEN SELECT SOME ACTIONS
 *  LIKE COMMIT PUSH DISCUSSTION SUPPOSE I SELECTED THIS THREE NOW WHENEVER IN OUR REPO IF SOMEONE COMMIT PUSH OR SOME DISCUSSION HAPPEN
 *  GIT WILL TRIGGER THAT CALLBACK URL OR WE CAN SAY WEBHOOK URL AND CALL OUR POST API THIS WAY OUR SERVER CAN GET INFO ABOUT THOSE EVENTS
 * 
 *  IN SIMPLE WORD ITS JUST POST API WHICH TRIGGER'S ON SPECIFIC EVENT
 * 
 */

/**
 *                                      THAT'S ALL ABOUT COMMUNICATION TECHNIQUES"
 */

